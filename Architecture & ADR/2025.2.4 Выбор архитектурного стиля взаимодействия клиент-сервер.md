

- **Статус:** Принято
- **Дата:** 9 февраля 2025

**1. Контекст и постановка проблемы:**

Необходимо определить, как будет организовано взаимодействие между клиентскими приложениями (веб-приложение, Telegram-бот, приложение для кухни) и серверной частью системы "TL Food". Это взаимодействие включает в себя:

- Получение списка блюд (с фильтрацией и сортировкой).
    
- Оформление заказа.
    
- Управление настройками автозаказа.
    
- Управление избранным.
    
- Получение уведомлений.
    
- Взаимодействие с Telegram-ботом (регистрация, отправка команд).
    
- Идентификация пользователей на кухне (через Face Recognition Service).
    
- Получение отчётов.
    

Требования к взаимодействию:

- **Надежность:** Взаимодействие должно быть надежным, с гарантированной доставкой запросов и ответов (или с механизмами повторных попыток).
    
- **Безопасность:** Взаимодействие должно быть защищенным (аутентификация, авторизация, шифрование данных).
    
- **Производительность:** Взаимодействие должно быть достаточно быстрым, чтобы не вызывать задержек в работе клиентских приложений.
    
- **Масштабируемость:** Архитектура должна позволять масштабировать серверную часть для обработки увеличивающегося количества запросов.
    
- **Простота разработки и поддержки:** Архитектурный стиль должен быть простым в реализации и поддержке, с учетом того, что проект разрабатывается студентами.
    
- **Гибкость**
    

**2. Рассматриваемые варианты:**

- **Вариант 1: RESTful API (Representational State Transfer).**
    
    - Описание: Архитектурный стиль, основанный на использовании стандартных HTTP-методов (GET, POST, PUT, DELETE) для взаимодействия с ресурсами (объектами системы). Данные передаются в формате JSON (или XML).
        
    - Преимущества:
        
        - **Простота:** REST – простой и понятный архитектурный стиль.
            
        - **Широкая распространенность:** REST – самый распространенный стиль для создания API. Большое количество инструментов, библиотек и готовых решений.
            
        - **Масштабируемость:** RESTful API хорошо масштабируются (за счет использования stateless-взаимодействия и кэширования).
            
        - **Независимость клиента и сервера:** Клиент и сервер могут разрабатываться независимо друг от друга, при условии соблюдения контракта API.
            
        - **Поддержка кэширования:** HTTP-кэширование позволяет снизить нагрузку на сервер и ускорить работу клиентских приложений.
            
        - **Большое сообщество и документация:** Легко найти ответы на вопросы и примеры реализации.
            
    - Недостатки:
        
        - **Неоптимальность для сложных сценариев:** В некоторых случаях (например, при необходимости получения большого количества связанных данных) может потребоваться много запросов к API, что снижает производительность.
            
        - **Избыточность данных:** Сервер часто возвращает больше данных, чем нужно клиенту (over-fetching).
            
        - **Недостаточная гибкость:** Клиент жестко привязан к структуре API, определенной сервером.
            
- **Вариант 2: GraphQL.**
    
    - Описание: Язык запросов для API и среда выполнения для этих запросов. Клиент сам определяет, какие данные ему нужны, и сервер возвращает только эти данные.
        
    - Преимущества:
        
        - **Гибкость:** Клиент получает только те данные, которые ему нужны (решение проблемы over-fetching).
            
        - **Эффективность:** Меньше сетевого трафика и более быстрая загрузка данных.
            
        - **Сильная типизация:** GraphQL использует схему, которая описывает типы данных, что помогает избежать ошибок.
            
        - **Удобство разработки:** GraphQL предоставляет инструменты для разработки и тестирования API (например, GraphiQL).
            
    - Недостатки:
        
        - **Сложность:** GraphQL сложнее в освоении, чем REST.
            
        - **Меньшая распространенность:** Меньше готовых решений и библиотек по сравнению с REST.
            
        - **Сложность кэширования:** Кэширование в GraphQL сложнее, чем в REST.
            
        - **Потенциальные проблемы с безопасностью:** Необходимо тщательно настраивать авторизацию и защиту от злоупотреблений.
            
- **Вариант 3: gRPC.**
    
    - Описание: Высокопроизводительный фреймворк RPC (Remote Procedure Call), разработанный Google. Использует Protocol Buffers для сериализации данных и HTTP/2 для передачи данных.
        
    - Преимущества:
        
        - **Высокая производительность:** gRPC, как правило, быстрее, чем REST и GraphQL, за счет использования бинарного формата данных (Protocol Buffers) и HTTP/2.
            
        - **Сильная типизация:** Использует Protocol Buffers, которые обеспечивают строгую типизацию данных.
            
        - **Поддержка двунаправленной потоковой передачи данных:** Позволяет клиенту и серверу обмениваться данными в режиме реального времени.
            
        - **Генерация кода:** Protocol Buffers позволяют автоматически генерировать код для разных языков программирования.
            
    - Недостатки:
        
        - **Сложность:** gRPC сложнее в освоении, чем REST.
            
        - **Меньшая распространенность:** Меньше готовых решений и библиотек по сравнению с REST.
            
        - **Ограниченная поддержка браузерами:** gRPC не поддерживается напрямую браузерами (требуется прокси-сервер, например, Envoy).
            
        - **Менее гибкий:** gRPC больше подходит для взаимодействия между сервисами, чем для взаимодействия между клиентом и сервером.
            
- **Вариант 4: SOAP (Simple Object Access Protocol).**
    
    - Описание: Протокол обмена структурированными сообщениями в распределенной вычислительной среде. Использует XML для передачи данных.
        
    - Преимущества:
        
        - **Строгая типизация:** Использует WSDL (Web Services Description Language) для описания сервисов.
            
        - **Поддержка транзакций:** SOAP поддерживает распределенные транзакции.
            
        - **Безопасность:** SOAP предоставляет широкие возможности для обеспечения безопасности (WS-Security).
            
    - Недостатки:
        
        - **Сложность:** SOAP – очень сложный протокол.
            
        - **Избыточность:** SOAP использует XML, который является очень объемным форматом данных.
            
        - **Низкая производительность:** SOAP, как правило, медленнее, чем REST и gRPC.
            
        - **Устаревший:** SOAP считается устаревшим протоколом и используется в основном в enterprise-системах.
            

**3. Решение:**

Использовать **RESTful API (Вариант 1)**.

**4. Обоснование решения:**

RESTful API является оптимальным выбором для данного проекта по следующим причинам:

- **Простота и распространенность:** Это ключевые факторы для студенческого проекта. REST легко понять и реализовать, для него существует множество инструментов и библиотек.
    
- **Достаточная функциональность:** RESTful API позволяет реализовать все необходимые сценарии взаимодействия между клиентами и сервером.
    
- **Масштабируемость:** RESTful API хорошо масштабируются.
    
- **Независимость клиента и сервера:** Это позволяет разрабатывать клиентские приложения и серверную часть параллельно.
    
- **Соответствие требованиям:** RESTful API соответствует всем требованиям к взаимодействию, перечисленным в разделе "Контекст и постановка проблемы".
    

Недостатки REST (потенциальная неоптимальность для сложных сценариев, избыточность данных) не являются критичными для данного проекта (MVP), и их можно минимизировать с помощью:

- Тщательного проектирования API (гранулярные ресурсы, использование HATEOAS).
    
- Кэширования (на стороне клиента и сервера).
    
- Использования пагинации (pagination) для больших списков данных.
    

GraphQL и gRPC являются более сложными технологиями, которые могут быть избыточными для данного проекта. SOAP считается устаревшим и не рекомендуется для новых разработок.

**5. Детали реализации:**

- **Формат данных:** JSON (как наиболее распространенный и простой формат).
    
- **HTTP-методы:**
    
    - GET: Получение данных.
        
    - POST: Создание новых ресурсов (например, оформление заказа).
        
    - PUT: Обновление существующих ресурсов (например, изменение настроек автозаказа).
        
    - DELETE: Удаление ресурсов (например, удаление блюда из избранного).
        
- **Коды ответов HTTP:** Использовать стандартные коды ответов (200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error и т.д.) для информирования клиента о результате выполнения запроса.
    
- **URI:** Использовать понятные и структурированные URI для ресурсов (например, /users/{userId}/orders, /menu/items, /menu/items/{itemId}).
    
- **Версионирование API:** Предусмотреть возможность версионирования API (например, /v1/users, /v2/users), чтобы обеспечить обратную совместимость при внесении изменений в API.
    
- **Документация:** Использовать инструменты для автоматической генерации документации API (например, Swagger, OpenAPI).
    
- **Аутентификация/Авторизация**: JWT  
    **6. Последствия:**
    
- **Положительные:**
    
    - Простая и понятная архитектура взаимодействия.
        
    - Быстрая разработка и внедрение.
        
    - Большое количество доступных инструментов и библиотек.
        
    - Хорошая масштабируемость.
        
- **Отрицательные:**
    
    - Потенциальная неоптимальность для очень сложных сценариев (но это маловероятно для данного проекта).
        

**7. Метрики:**

- **Время отклика API:** Среднее время ответа на различные запросы (GET, POST, PUT, DELETE).
    
- **Количество запросов в секунду (RPS),** которое может обработать API.
    
- **Процент ошибок:** Количество ошибок (HTTP-коды 4xx, 5xx) по отношению к общему количеству запросов.
    
- **Удовлетворенность разработчиков:** Насколько удобно разработчикам клиентских приложений использовать API (опрос, обратная связь).